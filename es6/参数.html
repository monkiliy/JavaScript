<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>参数</title>
</head>
<body>
    <script>
        /* // 参数的默认赋值 基本用法
        function fn(a,b,c){
            console.log(a,b,c);
        }
        fn(1,3,6);
        fn();//undefined

        function fn1(a = 1, b = 5, c = 7){
            console.log(a,b,c);
        }
        fn1(10);
        // 惰性赋值
        function fn2(value){
            return 20;
        }
        function fn3(a = fn2(), b = 4, c = 8){
            console.log(a, b, c);
        }
        fn3();
        fn3(30);//参数a 有实参传入，不会进行默认赋值 函数fn2 不会执行 惰性赋值 */

       /*  // 在默认值中使用变量
        function fn(a = 1, b = a){
            console.log(a, b);
        }
        fn();

        function fn1(a = b, b = 1){
            console.log(a, b);
        }//报错 因为参数默认赋值从左到右，a = b 而 b 此时未定义
        fn1();
        
        const c = 3;
        function fn(a = c, b = a){
            const c = 4;
            console.log(a,b);//a = 3 a = c 访问的是外部的 变量c
        }
        fn(); */

        /* // 剩余运算符
        // 把散列的元素变成一个数组 在函数中使用
        // 原生js
        function fn(a,b,c){
            var arr = Array.prototype.slice.call(arguments);
            console.log(arr);
            console.log(a + b + c);
        }
        fn(1,3,5);
        // 剩余运算符
        function fn1(...arr){
            console.log(arr);
        }
        fn1(1,3,5);
        // 注意点 只能在最后一项使用
        function fn2(a,...arr){
            console.log(arr);
        }
        fn2(3,4,5,6);//arr只有三项 [4,5,6]; */

       /*  // 在解构赋值中使用
        let [a,...b] = [1,3,5,];
        console.log(a,b); //b是一个数组 [3,5]；
        let {x,y,...z} = {x: 'c', y : 'f', z : '5', h : 'j'}
        console.log(x,y,z);// z 是一个对象 {z : '5, h : 'j};

        // 扩展运算符
        function fn(a,b,c){
            console.log(a,b,c);
        }
        fn([12,3,5]);// b, c 为undefined
        fn(...[1,2,6]); // a, b, c 分别为 1， 2， 6 */

/*         // 数组与对象的浅克隆 使用扩展运算符
        let arr = [1,3,5];
        let arr2 = [...arr];
        arr.push(7);
        console.log(arr2);
        console.log(arr);

        let array = [2,4,[1,3]];
        let array1 = [...array];
        array[2][1] = 10;
        console.log(array);
        console.log(array1);//浅拷贝 array1[2][1] 也变成10了 不等于3

        let obj = {
            x: 'c',
            y: 'b',
            z: 'a'
        }
        let obj2 = {
            ...obj
        }
        obj.n = 'm';
        console.log(obj2);
        console.log(obj); */

        // 模拟命名参数
        function fn(start, end){
            console.log(start, end);
        }
        fn(1,3);//函数调用的时候 没有语义化的参数名提示 代码可读性差

        // 1.使用对象传递参数 本质是对象的解构赋值
        function fn1({start,end}){
            console.log(start,end);
        }
        fn1({start: 1,end : 4});

        // 2.调用函数的时候传入空对象，使用解构赋值的默认赋值
        function fn2({start = 1, end = 5}){
            console.log(start, end);
        }
        fn2({});//采用默认赋值
        fn2({start : 10, end : 50});
        // fn2();报错
        // 因为 对象的结构赋值 模式不匹配报错 {start = 1, end = 5} = undefined 不传递参数 就是undefined
        
        // 3.调用函数的时候没有传递参数 使用参数的默认赋值
        function fn3({start = 2, end = 4} = {}){
            console.log(start, end);//增强代码可读性，并且不要再重复赋值声明变量 可以直接调用
        }
        fn3();//采用参数的默认赋值
        fn3({start: 20, end : 40});
    </script>
</body>
</html>